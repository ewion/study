학습개요
앞에서 학습한 이진 탐색 트리를 장점을 살려서 더 효율적으로 사용하기 위해 만든 멀티웨이 탐색 트리에 대해 학습합니다.
처음으로 이진 탐색 트리를 확장한 것으로 ｍ개 이하의 가지를 가질 수 있는 ｍ원 탐색 트리가 있습니다.
탐색 트리의 제한을 유지하면서 2개 이상(ｍ개 이하)의 자식을 가질 수 있습니다. BS 트리가 2-way 탐색에 해당합니다.
m원 탐색 트리는 파일의 인덱스를 구현할 경우에 특정 레코드를 빠르게 참조할 수 있습니다. 다음으로 B, B*, B+ 트리가 있습니다.
이 세 가지 트리의 조건을 명확하게 구분해서 이해해야 하고, 삽입과 삭제 방법을 비교하면서 학습하시는 것이 좋습니다. 우선, B트리는 세 가지 조건이 있는 트리입니다.
루트와 잎 노드를 제외한 트리의 각 노드는 최소 ⌈m/2⌉개의 서브트리를 갖으며, 트리의 루트는 최소한 2개의 서브트리를 갖는다. 그리고 트리의 모든 잎 노드는 같은 레벨에 있어야 한다는 조건입니다.
삽입과 삭제 연산을 진행할 경우에는 이 조건에 맞는지를 확인해야 합니다. B*트리는 노드의 약 2/3 이상이 차야하는 B트리입니다. 삽입, 삭제 시 발생하는 노드 분리를 줄이려고 고안한 것입니다.
B*트리는 노드가 꽉 차면 분리하지 않고, 키와 포인터를 재배치하여 다른 형제 노드로 옮깁니다. B+트리는 B트리와 같이 각 노드가 적어도 1/2이 차야 하는 점은 같습니다.
하지만 잎 노드를 순차적으로 연결하는 포인터 집합이 있다는 점에서 다릅니다. 또한 잎 노드가 모든 키값을 포함하고 있습니다. 따라서 순차 처리를 할 때는 왼쪽 끝부터 차례로 처리할 수 있는 장점이 있습니다.

학습목표
m원 탐색 트리의 정의와 탐색 방법을 이해할 수 있다.
B트리의 정의와 삽입 및 삭제 방법을 이해할 수 있다.
B*트리의 정의와 삽입 방법을 이해할 수 있다.
B+트리의 정의와 삽입 및 삭제 방법을 이해할 수 있다.

정리하기
트리의 노드가 m개 이하의 가지를 가질 수 있는 탐색 트리를 m원 탐색 트리라고 합니다.
m원 탐색 트리는 이진 탐색 트리를 확장한 것으로 탐색 트리의 제한을 따르되 2개 이상(m개 이하) 자식을 가질 수 있습니다.
인덱스 구조를 구현하는데 가장 일반적으로 사용하는 방법으로 차수가 m인 B트리가 있습니다.
B트리는 루트와 잎 노드를 제외한 트리의 각 노드는 최소 ⌈/2⌉개의 서브트리를 갖습니다.
B트리의 루트는 최소한 2개의 서브트리를 갖습니다.
B트리의 모든 잎 노드는 같은 레벨에 있습니다.
B트리의 삽입 연산에서 노드가 꽉 차있는 경우는 분리해서 키값과 포인터를 재분배해야 합니다.
B트리 삭제 연산에서 삭제 결과 개수가 부족하면 그 노드를 다른 노드와 묶어야 합니다.
노드의 약 2/3 이상이 차야하는 B트리를 B*트리라고 합니다.
B*트리는 노드가 꽉 차면 분리하지 않고, 키와 포인터를 재배치하여 다른 형제 노드로 옮깁니다.
B+트리는 인덱스된 순차 파일을 구성하는데 사용합니다. 인덱스된 순차 파일은 데이터를 차례로 처리하는 순차 처리와 특정 데이터를 직접 찾아 처리하는 두 가지를 모두 효율적으로 할 수 있는 구조입니다.
B+트리는 잎 노드의 마지막 포인터는 다음 키값을 갖는 노드를 가리킵니다. 따라서 순차 처리를 할 때는 이 포인터를 이용해서 차례로 다음 데이터에 접근해서 처리할 수 있습니다.
B+트리에서는 모든 키값이 잎 노드에 있고 그 키값에 대응하는 실제 데이터에 대한 주소를 잎 노드만이 가지고 있습니다.

1. m원 탐색트리
 이진 탐색 트리
 - 트리에서 특정 데이터를 검색하고 노드의 삽입/삭제 연산이 자주 발생하는 응용 문제에 효과적인 이진 트리
 - 자식 노드가 두개이므로 한번에 두번의 검색만 함. 탐색에 특화된 트리
 - 왼쪽과 오른쪽이라는 방향성을 가지며 다루기가 매우 편리
 - 부모 노드를 중심으로
   부모보다 작은 데이터 노드 (왼쪽 서브트리)와
   부모보다 큰 데이터 노드 (오른족 서브트리)로 구분
 - 노드의 개수가 많아지면 트리의 높이가 커짐
 - 같은 개수의 노드에도 불구하고 트리의 높이를 높지 않게 유지 할 수 있는 트리 자료구조가 필요함
 - BS 트리가 2원(2진, 2-way, 자식 노드가 2개를 넘지 않음) 탐색 트리임

 m원 탐색 트리의 정의
 - 트리의 노드가 m개 이하인 가지를 가질 수 있는 탐색 트리
  같은 수의 노드를 갖는 이진 트리보다 낮은 높이의 m원 트리
 - 이진 탐색 트리의 확장된 형태임, 이진 탐색 트리의 형제 관계
 - 탐색 트리의 제한을 따르면서 2개 이상~m개 이하의 자식 노드를 가질 수 있음

 m원 탐색 트리의 탐색 연산
 - 일반적으로 노드의 가지 개수가 많을 수록(서브트리가 많을 수록) 최대 탐색 시간이 짧아짐.
   트리의 깊이가 얕아 더 빨리 찾을 수 있음

2. B 트리
 B 트리
 - m원 탐색 트리는 서브 트리의 균형에 대해서는 특별히 제한하지 않음
 - 각 노드가 자식을 많이 갖게 하여 트리의 높이를 줄이고 전체적으로 균형을 유지한다면 탐색 성능을 더욱 향상할 수 있음
 - m원 탐색 트리를 개선한 B트리는 인덱스 구조를 구현하는데 가장 일반적으로 사용함(효율적임, B+트리가 가장 효율적)
 - 차수 m인 B트리의 탐색 굥로 길이는 같은 개수의 키를 가지는 이상적인 m원 탐색 트리보다 길 수 있지만,
   이상적인 m원 탐색 트리의 유지 비용에 비해 키 값을 삽입하거나 삭제할 때 B트리를 유지하는 것이 더 효율적(쉬움)

 B 트리의 조건
 - 루트와 잎 노드를 제외한 트리의 각 노드는 [m/2] 개의 서브 트리를 갖는다
 - 트리의 루트는 최소한 2개의 서브 트리를 갖는다
 - 트리의 모든 잎 노드는 같은 레벨에 있다

 B 트리에 키를 삽입하는 알고리즘
  1. 삽입할 위치를 찾기 위해 노드의 키 값을 왼쪽에서 오른쪽으로 탐색한다 (B트리에서 모드는 노드는 잎 노드에서 삽입 시작)
  2. 노드에 빈 자리가 있으면 삽입 후 종료
  3. 노드가 꽉 찼으면 노드를 2개로 분리하고 키와 포인터를 새 노드에 반씩 할당한다
   3-1. 잎 노드 키값과 삽입 노드 키값 중에서 중간값을 선택
   3-2. 선택된 중간값보다 작은 키 값을 갖는 것은 왼쪽 노드에 넣고 큰 것은 오른쪽 노드에 넣는다
   3-3. 중간값을 가지는 노드의 키 값과 포인터를 부모노드에 삽입, 만일 부모 노드가 루트 노드면 두 노드를 가리키도록(자식 노드가 되도록) 수정한다.

 B 트리에 키를 삭제하는 알고리즘
 - 삭제할 키 값을 포함할 노드를 찾는다
 - 잎 노드에서 삭제하는 경우
  잎 노드에서 키값을 삭제
  필요한 경우 재배열
 - 내부 노드에서 삭제하는 경우
  내부 노드의 키 값은 하위 노드에 대한 기준값이기 때문에 삭제시 대체할 적절한 값을 찾아야 함
  보통 왼쪽 서브 트리의 가장 큰 키 값 또는 오른쪽 서브트리의 가장 작은 키 값으로 대체 가능. 이들은 모두 잎 노드에 위치
  새로운 기준값(삭제된 자리에 올 키 값)을 선택하여 해당(잎) 노드에서 삭제하고 그 값을 현재 키 값을 삭제한 자리로 옮긴다. 즉 대체한 것
  기준값으로 대체하기 위해 키를 삭제한 잎 노드가 정해진 개수의 키 값을 갖지 않으면 트리를 재배열
 - 재배열
  1. 키 값이 부족한 노드의 오른쪽 형제가 존재하고 키가 정해진 최소 개수보다 많다면 왼쪽으로 회전
   1-1. 부모 노드의 기준키값을 개수가 부족한 노드의 끝으로 이동, 즉 기준값을 한 단계 아래로 내려 개수를 채운다
   1-2. 부모 노드의 기분값을 오른쪽 형제의 첫 번째 키로 수정해 균형을 맞춘다
  2. 키 값이 부족한 노드의 왼쪽 형제가 존재하고 키가 정해진 최소 개수보다 많다면 오른쪽으로 회전
   2-1. 부모 노드의 기준키값을 개수가 부족한 노드의 끝으로 이동, 즉 기준값을 한 단계 아래로 내려 개수를 채운다
   2-2. 부모 노드의 기준값을 왼쪽 형제의 마지막 키로 수정해 균형을 맞춘다
  3. 좌우 형제가 최소개수의 키를 가지고 있다면 좌우 형제를 합친다
   3-1. 부모 노드의 기준 키 값을 왼쪽 노드의 마지막에 복사한다
   3-2. 오른쪽 노드의 모든 키 값을 왼쪽 노드로 옮긴다
   3-3. 키를 갖지 않는 오른쪽 노드는 삭제한다
   3-4. 부모 노드가 루트면서 키를 더 이상 갖지 않으면 합쳐진 노드가 새로운 루트가 된다.
        그렇지 않고 부모 노드의 키 개수가 정해진 최소 개수보다 작으면 부모 노드를 재배열 한다
  많은 쪽 노드에서 가져오는 개념

3. B*, B+ 트리
 B* 트리의 정의
 - 노드의 약 2/3이 채워지는 트리
 - 노드가 꽉 차면 분리하지 않고 키와 포인터를 재배치하여 다른 형제 노드로 옮김
 - B트리와 동일한 수의 노드를 갖는다면 높이가 낮고, 삽입/삭제 시 발생하는 노드 분리를 줄이력 고안
 - 차수가 m인 B*트리는 다음 조건을 만족하는 B트리이다
  1. 공집합이거나 높이가 1이상인 m원 탐색트리이다
  2. 루트 노드는 2개 이상 2[(2m-2)/3]+1 개 이하의 자식 노드를 가진다
  3. 내부 노드는 최소한 2[(2m-1)/3] 개의 자식 노드를 가진다
  4. 모든 잎 노드는 동일한 레벨에 놓인다
  5. 포인터가 k개 이면서 잎 노드가 아닌 노드는 k-1 개의 키를 갖는다. (루트 노드 포함)

 B+ 트리의 정의
 - 탐색 트리로 구성하면 매우 빠르게 탐색할 수 있지만 전체 데이터를 차례로 처리하기는 불편함
 - 매번 왼쪽인지 오른쪽인지 비교해가면서 다음 노드를 찾아가면서 처리해야 함
 - B+ 트리는 인덱스된 순차 파일을 구성하는 데 사용
 - B트리와 같이 각 노드의 키가 적어도 1/2는 채워져야 하는 것은 같음