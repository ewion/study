학습개요
그래프에 대해서 할 수 있는 가장 기본적인 연산은 특정 정점이 그래프 내에 있는지 찾는 것입니다.
그러기 위해서는 그래프내의 모든 정점을 빠짐없이 그리고 중복 없이 돌아다녀야 합니다. 그것을 그래프 순회라고 합니다.
그래프 순회에는 두 가지 방법이 있습니다. 15장에서는 깊이 우선 탐색(Depth First Search; DFS)과 너비 우선 탐색(Breadth First Search; BFS)이라는 그래프 순회에 대해 설명합니다.
마지막으로 가중 그래프에서 비용이 최소인 트리를 생성하는 3가지 (프림, 크루스컬, 솔린)알고리즘을 상세하게 다루어 보겠습니다.

학습목표
주어진 그래프에 대해 깊이 우선 순회와 너비 우선 순회를 할 수 있다.
최소 비용 신장 트리가 무엇인지를 설명할 수 있다.
프림 크루스컬, 솔린 알고리즘을 적용하여 주어진 그래프에서 최소 비용 신장 트리를 생성할 수 있다.

정리하기
 그래프 내 특정 정점을 찾는 연산을 그래프 탐색이라 합니다. 그래프는 트리와 다르게 루트노드가 없으므로 시작을 나타내는 특정 정점이 주어집니다.
(트리에서 노드로 부르는 것을 그래프에서는 보통 정점이라 합니다. 이 책은 그렇게 용어를 사용했습니다.)
 특정 정점에서 시작하여 그래프의 모든 정점을 빠짐없이 그리고 중복 없이 방문하는 것을 그래프 순회라고 합니다.
그래프 탐색은 순회를 통하여 정점을 방문하다가 정해진 정점을 만나면 탐색 성공이고 모든 정점을 방문해도 정해진 정점을 만나지 못하면 실패입니다.
 깊이 우선 탐색은 특정 점정에서 시작하여 자손을 먼저 방문 한 후 (더 이상 방문 할 자손이 없으면) 전 단계 형제를 방문하는 알고리즘입니다.
그래프는 루트가 없고 간선에 방향도 없으므로 어려워합니다. 시작 정점을 위에 올려놓고 생각하면 다소 쉬워집니다. 특히 시각적으로 더 위에 있는 것이 더 깊은 곳일 수 도 있음을 받아들이면 이해에 도움이 됩니다.
 너비 우선 탐색은 특정 정점에서 시작하여 모든 형제를 방문한 후 자손을 방문하는 순서를 따릅니다.
자식이 여러 개인 경우 그것들의 순서를 정하는 규칙만 정하면 역시 어렵지 않게 이해 할 수 있습니다.
 그래프의 모든 정점을 포함하는 사이클이 없는 부분 그래프 즉, 트리를 신장트리라 합니다.
그리고 가중 그래프에서 비용이 최소인 신장 트리를 최소 비용 신장 트리라 합니다.
대표적으로 프림, 크루스컬, 및 솔린 알고리즘을 사용합니다. 모두 사람 이름입니다.
 프림 알고리즘은 최소비용을 갖는 간선을 차례로 추가하는 방법으로 트리를 구축합니다.
물론 사이클이 형성되면 해당 간선은 포기합니다.
비용이 적은 것을 합치면 그들의 합이 최소가 될 것이라는 (항상 옳지는 않은) 가정을 근거로 합니다.
 크루스컬 알고리즘 프림 알고리즘처럼 현재 완성한 트리에 간선을 붙여 트리를 키워나가는 것이 아닙니다.
이 알고리즘은 매 단계 최소 비용 간선을 선택해 사이클만 형성하지 않으면 받아 들이는 것입니다. 그러니까 중간 과정은 (트리가 아니고) 숲 일 수 있습니다.
 솔린 알고리즘은 앞 두 방법과 다르게 매 단계에 다수의 간선을 선택합니다. 먼저 간선이 하나도 없고 그래프의 모든 정점들로 구성된 숲에서 시작합니다.
그리고 단계가 거듭되면서 숲 내의 트리를 최소 비용을 갖는 간선으로 연결합니다. 이 과정을 남은 간선이 없거나 완전한 트리가 생성될 때까지 반복하면 신장 트리를 얻습니다.

1. 그래프 탐색
 개요
 - 그래프에서 특정 정점을 찾는 연산
 - 그래프 G ={V, E} 와 V{G} 에 있는 정점이 v가 주어졌을 때 정점 v에 도달할 때 까지 G의 정점을 방문하는 연산
 - 만일 그래프 내에 정점이 v가 없다면 그래프의 모든 정점을 방문 후 종료함
 - 그래프 탐색(순회) :
  깊이 우선 탐색 Depth First Search DFS
  너비 우선 탐색 Breadth First Search BFS 두 가지 방법있음

 깊이 우선 탐색
  1. 시작 : 출발점 v를 방문
  2. 다음으로 v에 인접하고 아직 방문하지 않은 정점 w를 선택하여 w를 출발점으로 다시 깊이 우선 탐색(인접하고 방문하지 않은 정점 선택)
  3. 위의 두 과정을 모든 정점을 한 번씩 방문할 때까지 반복
 만약 인접한 모든 정점들이 이미 방문한 정점인 경우인 경우는 가장 최근에 방문한 정점 중에서 방문하지 않은 정점 w를 가진 정점을 선택하여 정점 w로부터 다시 깊이 우선 탐색을 시작함
 -> 스택을 사용하여 가장 최근에 선택의 지점에 있던 정점을 찾아냄
 방문하지 않은 정점이 없으면 탐색을 종료함

2. 최소 비용 신장 트리
 개요
 - 트리 : 사이클이 없는 단순 그래프
 - 트리는 그래프이기는 하지만 루트를 가지기 때문에 (일반 그래프에는 없는) 계층 개념이 있고, 사이클이 없어 한 정점에서 다른 정점으로 가는 경로가 유일한 구조

 정의
 - 신장 트리
  그래프 G의 모든 정점과 간선의 일부(또는 전부)를 포함하는 트리
  주어진 그래프의 정점을 모두 포함함
  n-1 개의 간선으로 구성한 그래프
 - G의 최소 부분 그래프 :
  그래프 G의 부분 그래프 중에서 간선의 수가 가장 작은 것
 - 언제나 최소값만으로는 만들어지지 않음, 사이클을 피하는것이 먼저이기 때문

 프림 알고리즘
 - n개의 정점을 갖는 연결 그래프 G에 대한 최소비용 신장트리 T를 구하는 알고리즘
 - 그래프 전체에서 최소 비용을 갖는 간선 {u,v} 를 선택하여 이 간선을 최소비용신장트리 T 에 추가함
 - 이 간선을 최소비용신장트리 T 에 추가하였을때 사이클을 형성하지 않으면 T에 추가하고 아니면 무시함

 크루스컬 알고리즘
 - 남은 간선 중에서 무조건 최소 비용인 간선을 선택한 후 사이클을 형성하지 않으면 그 간선을 선택함
 - 중간 과정에 있는 T는 하나의 트리가 아니고 여러개의 분리된 트리, 즉 숲일 수 있음

 솔린 알고리즘
 - 간선이 하나도 없는 그래프들의 모든 정점들로 이루어진 숲에서 시작함
 - 단계가 거듭되면서 숲 내의 트리들이 최소비용을 갖는 간선으로 연결