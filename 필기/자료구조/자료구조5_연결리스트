목표
리스트와 배열의 차이점을 이해할 수 있다.
연결 리스트의 구현을 위한 포인터 개념을 이해할 수 있다.
연결 리스트의 노드 삭제를 위한 포인터 변수의 운영을 이해할 수 있다.

정리
리스트의 ‘순서’는 데이터가 저장되는 물리적인 위치와 상관없이 사람들의 머릿속에 인식되는 ‘논리적인 순서’, 혹은 리스트에 나타나는 원소들 간의 ‘의미적인 순서’를 의미합니다.
배열을 이용한 리스트의 구현은 실제 IT 서비스 환경에서는 자주 사용되지 않고 있습니다. 자료의 삽입과 삭제가 빈번히 발생하는 상황에서, 리스트를 배열로 구현하는 것은 빈번한 자료 이동으로 인한 비효율적인 컴퓨팅 성능을 유발합니다.
포인터를 이용하는 방법은 원소의 자리에는 원소값을 저장하고, 다음 원소를 가리키는 정보의 자리에는 다음 원소가 저장될 위치의 주소값을 저장합니다. 조금 더 ‘프로그램’스럽게 설명하자면, 리스트의 원소 자리와 다음 원소를 가리키는 정보의 자리를 합쳐서 노드(node)라고 합시다. 노드에는 데이터 요소(원소)와 리스트의 다음 원소를 지시하는 포인터(pointer, 주소)를 가진다고 생각하면 됩니다. 이 포인터는 링크(link)라고도 부릅니다.
포인터의 ‘메모리 주소값’이라는 것은 메모리에 저장되는 값의 위치라고 생각하면 됩니다. 메모리에 저장되는 값(데이터)은 저장 위치에 대한 주소를 가지며, 이 저장 위치를 이용해서 리스트의 원소값을 찾아갈 수 있습니다.
다양한 데이터형의 변수를 하나의 상자 안에 넣어서 선언하거나 사용하는 C 프로그래밍 문법이 구조체(struct)입니다.

정리하기
리스트의 ‘순서’는 데이터가 저장되는 물리적인 위치와 상관없이 사람들의 머릿속에 인식되는 ‘논리적인 순서’, 혹은 리스트에 나타나는 원소들 간의 ‘의미적인 순서’를 의미합니다.
배열을 이용한 리스트의 구현은 실제 IT 서비스 환경에서는 자주 사용되지 않고 있습니다.
자료의 삽입과 삭제가 빈번히 발생하는 상황에서, 리스트를 배열로 구현하는 것은 빈번한 자료 이동으로 인한 비효율적인 컴퓨팅 성능을 유발합니다.
포인터를 이용하는 방법은 원소의 자리에는 원소값을 저장하고, 다음 원소를 가리키는 정보의 자리에는 다음 원소가 저장될 위치의 주소값을 저장합니다.
조금 더 ‘프로그램’스럽게 설명하자면, 리스트의 원소 자리와 다음 원소를 가리키는 정보의 자리를 합쳐서 노드(node)라고 합시다.
노드에는 데이터 요소(원소)와 리스트의 다음 원소를 지시하는 포인터(pointer, 주소)를 가진다고 생각하면 됩니다. 이 포인터는 링크(link)라고도 부릅니다.
포인터의 ‘메모리 주소값’이라는 것은 메모리에 저장되는 값의 위치라고 생각하면 됩니다.
메모리에 저장되는 값(데이터)은 저장 위치에 대한 주소를 가지며, 이 저장 위치를 이용해서 리스트의 원소값을 찾아갈 수 있습니다.
다양한 데이터형의 변수를 하나의 상자 안에 넣어서 선언하거나 사용하는 C 프로그래밍 문법이 구조체(struct)입니다.

1. 리스트의 개념
 개요
 - 배열과 같이 생각하고, 배열과의 차이를 염두에 둘 것
 - 일정한 순서의 나열, 어떤 정의에 의해 결정된 논리적인 순서의 나열
 - 배열은 인덱스로 표현되는 추성적 순서가 배열 원소의 메모리공간에서의 물리적 위치와 일치함
 - 하지만 리스트의 순서개념은 어떤 정의에 의해 결정된 논리적 순서임 ( ex) 역사적 사건들의 순서는 바꿀수 없음, 1차대전과 2차대전의 발발순서 등)
 - 원소들의 물리적인 저장 순서나 위치와는 무관하게 원소들 간의 논리적인 순서만 유지함

 배열의 정의
 - 원소의 메모리 공간(메인 메모리, DDR) 의 물리적인 위치를 순서적으로 결정하는 특징
 - 배열의 순서는 메모리 공간에서 저장되는 원소값의 물리적 순서

2. 배열을 이용한 리스트의 구현
 배열을 이용한 리스트의 원소 삽입
 -

 배열의 확장
 - 초기 배열 선언에서 충분히 크게 하면 배열의 추가확장을 피할 수 있겟지만, -> 메모리 낭비
 - 원소를 중간에 삽입하기 위해서는 리스트의 원소값을 하나씩 뒤로 밀어야 하는 상황 발생 -> 연산시간 증가

 배열을 이용한 리스트의 문제점
 - 배열로 구현된 리스트는 원소의 순서가 연속적인 물리적 주소에 저장됨
 - 원소를 삽입하거나 삭제하기 위해서는 해당 원소의 위치 뒤에 있는 모든 원소를 뒤로 물리거나 앞으로 당겨야됨
 - 리스트 원소값의 이동은 원소수가 많을수록 수행시간을 증가 (비효율적)
 - 현재 프로그램들은 자료의 삽입과 삭제가 빈번하게 일어나기 때문에 배열을 이용한 리스트는 잘 사용하지 않음

3. 포인터를 이용한 리스트의 구현
 노드의 구조
 - node : 리스트의 원소값(데이터) + 다음 원소를 가리키는 정보(포인터)
 - 노드는 데이터 요소(원소값)와 리스트의 다음 노드를 지시하는 포인터(주소, 링크)로 구성됨

4. 포인트 변수


5. 연결 리스트의 삽입과 삭제
 리스트의 원소 삭제 연산 단계
 1. 삭제할 노드의 선행 노드의 링크 필드를 삭제할 노드의 후행 노드를 가리키게한다
 2. 삭제할 노드를 메모리에 반환한다

 리스트의 원소 삽입 연산 단계
 1. 메모리 공간을 할당받고 삽입할 내용을 저장하여 삽입할 x노드를 생성
 2. x노드의 링크부분이 후행 노드가 될 j노드를 가리키게 함
 3. 삽입될 x노드의 선행 노드가 될 i노드의 링크 필드가 x노드를 가리키게 함