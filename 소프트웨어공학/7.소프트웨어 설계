주요용어
소프트웨어 아키텍처 : 소프트웨어 구조를 말하며 시스템을 구성하는 요소들과 그들 간의 관계를 의미함
아키텍처 스타일 : 유사 애플리케이션들에 적용되는 공통적인 아키텍처 패턴으로 같은 부류의 시스템을 설계할 때 초안으로 사용될 수 있는 아키텍처
구조적 설계 : 데이터 흐름을 분석하여 시스템을 기능적으로 분해하는 전통적 설계 방법
결합도와 응집력 : 결합도는 두 모듈 간의 상호 의존성 정도를 의미하며, 응집력은 한 모듈이 가지는 기능적 집중성에 관한 상대적 척도

내용
1. 설계 개요
 개념
 - 요구사항의 구현을 위한 방법을 명시하는 것

 설계 프로세스
 - 설계작업 입력
 - 설계작업의 결과물
  구성요소들과의 관계를 보여주는 소프트웨어 아키텍처
  요소들의 인터페이스와 알고리즘
  데이터에 관한 정의
 - 설계프로세스는 반복적 프로세스로 초기 버전을 만들고 지속적으로 수정하면서 점점 정형화를 가하고 세세하게 기술

 설계 원리 - 문제분할
 - 분할 후 정복 : 문제를 작은것으로 분할하고 각각을 독립적으로 정복
 - 수평 분할
  기능들을 분리된 가지에 할당
  단순한 형태는 입력작업, 데이터변환, 출력작업을 담당하도록 분리
  테스트, 유지보수, 확장이 용이하고 부작용의 파급효과가 줄어듬
  많은 데이터가 모듈인터페이스를 통해 이동되어 전체 제어가 복잡해짐
 - 수직 분할
  제어 모듈과 작업 모듈을 위아래로 분산
  상위 수준의 모듈들은 제어기능, 하위 모듈은 실제 작업을 수행
  작업 모듈이 변경되기 쉬우며 제어모듈이 변경되면 부작용이 큼

 설계 원리 - 추상화
 - 추상화 : 상세한 내용을 생략하고 외부 행위만을 기술
 - ex) 자바의 인터페이스
 - 추상화의 적용
  시스템 설계에서 구성 모듈들을 추상화하여 표현
  추상적으로 표현된 다른 모듈이 존재하므로 상세 설계 단계에서 하나의 모듈에 집중할 수 있음
  추상화된 시스템 모델을 통해 시스템 분석이 가능함
 - 기능 추상화
  수행하는 기능으로 모듈 명세
  전체를 작은 기능들로 분해하는 것(기능중심의 분할방법)
 - 데이터 추상화
  데이터와 데이터 조작에 필요한 오퍼레이션을 함께 묶는 것
  객체의 상세한 구현내용을 감추어지며 데이터 조작에 공개된 오퍼레이션만을 사용해야 함

 설계 원리 - 하향식과 상향식 설계
 - 하향식 설계
  계층구조상에서 시스템의 주요 컴포넌트들을 찾고 그것을 낮은 수준의 컴포넌트드롤 분해하는 것
  단계적 정제라 하며 메인모듈의 설계에서 시작하여 단계적으로 구체화시키는 것
 - 상향식 설계
  가장 기본적인 컴포넌트를 먼저 설계, 이것을 사용하는 상위 수준의 컴포넌트 설계
 - 고려사항
  시스템 명세가 명확한 경우나 모든것을 새로 개발하는작업에는 하향식이 적합
  기존 컴포넌트를 조합하여 개발하는 경우 상향식이 적합

2. 아키텍처 설계
 개념
 - 초기 설계
 - 시스템의 주요 기능을 제공하는 구성요소들을 식별하고 관계를 정하는 것
 - 시스템의 품질 특성과 제약사항을 반영해야 함

 중요성
 - 개발이 진행된 후 시스템 구조를 수정하기 어려움
 - 설계 초기에 이루어지며 개발과정에 큰 영향
 - 주요 구성요소들을 개별적으로 명세하기 위한 출발점
 - 프로젝트 참여자들 사이의 중요한 의사소통 수단

 아키텍처 스타일
 - 유사한 앱들의 사용되는 공통적인 아키텍처 패턴
 - 미리 만들어진 시스템 설계 모델로 아키텍처 설계의 초안이 됨
 - 아키텍처 스타일에 따라 적합한 응용분야가 있으며 장단점이 알려져 있음

 데이터 중심 아키텍처 - 저장소 모델
 - 서브시스템 간 대규모 데이터를 공유하는 소프트웨어 시스템에 사용됨
 - 공유된 데이터베이스에 기반한 아키텍처로 저장소를 통해 상호 작용
 - 장점
  데이터 관리 효율적
  데이터 생성 서브시스템과 사용 서브시스템이 서로 독립적
  공유 데이터 모델을 사용하는 경우 시스템 확장에 용이
 - 단점
  서브시스템은 공통의 데이터모델을 사용해야 함
  중앙저장소 성능이 저하되면 병목현상
  모든서브시스템에 동일한 정책 적용
  데이터 모델을 변경시 큰 비용 발생

 데이터 흐름 아키텍처 - 파이프 필터 구조
 - 데이터 요소들에 대한 개별변환 작업들을 연결하여 시스템 구성
 - 사용자 간섭 없이 데이터 스트림에 일련의 변환 작업을 적용하는 시스템에 적합
  구성 요소들 간 복잡한 상호작용이 요구되는 경우 적합하지 않음

 클라이언트 - 서버 아키텍처
 - CS모델
 - 특정 서비스를 제공하는 서버의 집합과 서비스를 이용하는 클라이언트들로 시스템 구성
 - 장점
  데이터와 데이터 처리 분산
  분산된 프로세스들을 효율적으로 사용할 수 있음
  새로운 서버 추가, 업그래이드 용이
 - 단점
  공유 데이터 모델이 없으므로 데이터 교환이 비효율적
  모든 서버가 각각 데이터 관리 책임을 가짐

 계층형 아키텍처 - 추상 기계 모델
 - 시스템을 계층별로 구성
 - 하위 계층이 제공하는 서비스를 상위 계층이 이용
 - 특징
  각 계층은 특정 서비스를 제공, 서브시스템들의 점증적 개발 가능
  특정 계층의 인터페이스가 변경되면 인접 계층만 영향을 줌
  실제로는 시스템을 계층 구조로 개발하기는 어려움

 MVC 아키텍처 - MVC모델
 - 시스템의 기능을 도메인 지식을 관리하는 모델, 사용자에게 노출되는 뷰, 사용자와 상호작용하는 컨트롤러로 분리
 - 고려 사항
  저장소 모델의 특수한 형태
  하나의 모델에 대해 여러 뷰를 제공해야 하는 대화영 시스템, 또는 웹기반 시스템에 적합

 3계층 아키텍처
 - 클라이언트-서버모델의 개선된 형태
 - 사용자 인터페이스, 앱 로직, 저장소의 3계층이로 분리하여 시스템 구성
  사용자 인터페이스 계청은 사용자와의 상호작용 담당
  앱 로직 계층은 앱이 필요로 하는 기능 담당
  저장소 계층은 데이터 관리 담당
 - 고려사항
  인터페이스 계층과 앱로직계층을 분리함으로써 같은 앱에 대해 다른 사용자 인터페이스의 갭ㄹ 가능
  앱 로직이 자주 바뀌는 경우 대응 용이
  대규모의 서비스에 적합

 아키텍처와 비기능 속성
 - 소프트웨어 아키텍처는 비기능적 요구사항에 큰 영향을 줌
 - 비기능적 속성을 고려하여 설계해야 함
  성능 : 서브시스템들간의 통신 최소화
  보안 : 계층형 아키텍처 사용하고 보안이 중요한 계층은 내부에 위치
  안전성 : 안전성이 요구되는 요소들을 하나의 서브시스템에 집중
  가용성 : 동일기능의 컴포넌트 중복시킴
  유지보수성 : 자료공유 피하고 모듈화
 - 모순되는 점이 존재하므로 타협 필요
  성능을 위해서는 큰규모의 컴포넌트가 좋으나 유지보수성, 유지비에서 손해
  중복된 데이터를 유지하는 것은 가용성은 좋으나 더많은비용발생, 보안유지에 결함

3. 구조적 설계
 개념
 - 구조적 분석의 결과물을 이용해 아키텍처 설계하고 모듈 개발하는 방법
  아키텍처 표현을 위해 구조도 사용
  구조적 설계에서 아키텍처 설계는 데이터 흐름도에 표현된 정보의 흐름을 이용하여 구조도로 변환하는 작업
  구조도는 모듈들의 게층 구조와 제어 구조를 보여줌
 - 결과물은 구조도 모듈명세서 자료사전

 구조도
 - 모듈들의 계층구조, 모듈의 매개변수, 모듈들간의 상호연결관계를 보여줌
  모듈들은 블랙박스로 표현되며 계층적 배열
  상위모듈이 하위모듈 호출, 위애서 아래, 좌에서 우로 해석됨
 - 구조도의 구성 요소
  모듈 라이브러리 모듈
  데이터흐름, 제어흐름
  호출, 선택적호출, 반복적 호출

 데이터 흐름도를 구조도로 변환하는 방법
 1) 데이터 흐름의 유형 선정(변환 흐름과 트랜잭션 흐름)
 2) 흐름 경계선을 파악
 3) 데이터 흐름도를 구조도로 변환
 4) 제어 계층 정의
 5) 산출된 흐름도를 검토, 정비

 변환 분석에 의한 구조적 설계
 - 데이터 흐름의 유형이 변환흐름인 경우 사용
 - 변환 흐름은 데이터를 입력받고 변환/가공하고, 결과를 출력하는 유형
 - 변환 분석
  데이터 흐름도에서 입력흐름과 출력흐름의 경계 표시
  구조도에 입력 변환 출력모듈을 제어하는 모듈을 추가로 만듬

 트랜잭션 분석에 의한 구조적 설계
 - 데이터흐름의 유형이 트랜잭션 흐름인 경우 사용
 - 트랜잭션 흐름은 한 프로세스에서 입력을 여러경로의 데이터 흐름으로 유출하는 유형
 - 트랜잭션 분석
  트랜잭션 소스를 식별하고 트랜잭션 중심 모듈 찾음
  전체를 제어하는 모듈 추가
  데이터 수신 경로와 트랜잭션 중심에 해당하는 모듈을 하위에 위치시킴
  처리 부분에 있는 프로세스를 모듈로 변환

4. 상세 설계와 모듈화
 개념
 - 개별 모듈에서 사용되는 자료구조와 알고리즘을 자세히 설계
 - 아키텍처 설계는 비기능 요구사항에 초점을 둠

 모듈화
 - 시스템을 여러 분리된 컴포넌트들로 나누어 구성하는 것
 - 모듈화된 시스템은 잘 정의되고 관리 가능한 단위들로 구성되며 각 단위들은 잘 정의된 인터페이스를 통해 소통함
 - 장점
  구성 요소들이 기능적으로 독립적이라 이해하기 용이
  구성 요소들을 독립된 단위로 문서화 할 수 있음
  작고 간단한 문제에 집중할 수 있음
  테스트와 디버깅 유지보수 작업이 쉬움
  재사용하기 용이

 모듈의 독립성
 - 모듈의 독립성으로 시스템의 설계결과를 평가할 수 있음
  기능이 분리될 수 있고, 인터페이스 관계가 단순해 지며, 다른 모듈과의 상호작용이 최소화 됨
  따라서 개발작업 테스트작업이 쉬워지고 수정할 때 파급효과 적음
 - 모듈 독립성 평가
  하나의 모듈은 높은 응집력을 가져야 함
  다른 모듈과의 결합도가 느슨해야 함

 결합도
 - 두 모듈 사이의 상호의존성, 두 모듈을 연결하는 인터페이스에 복잡도에 좌우됨
  데이터의 수와 유형, 공유데이터 사용 여부, 제어흐름 전달 여부 판단
 - 결합도 수준
  데이터 결합 : 기본유형의 데이터(가장 느슨,가장 좋은 케이스)
  스탬프 결합 : 구조체와 같은 복합자료
  제어 결합 : 제어 플래그
  공통 결합 : 전역변수 공유
  내용 결합 : 코드 공유

 응집력
 - 하나의 모듈이 가지는 기능적 집중성에 관한 척도
  모듈을 구성하는 요소들이 기능적으로 얼마나 관련성이 있는가
 - 응집려구 수준
  기능적 : 요소들이 단일 작업을 수행하기 위해 협력(가장 강함)
  순차적 : 한 요소가 출력한 것이 다른요소의 입력이 됨
  통신 : 수행하는 기능들이 같은 자료구조를 다룸
  절차적 : 특정 순서를 따르는 기능들
  시간적 : 같은 시간 주기에 실행되는 기능들
  논리적 : 같은 범주에 기능들(모든 출력 수행하는 모듈)
  우연적 : 관계 없는 기능들

5. 객체지향 설계 원칙 - SOLID
 단일 책임 원칙 - SRP
 - 모든 클래스는 하나의 책임을 가져야 한다, 유일한 이유로만 변경될 수 있다

 개방 폐쇄 원칙 - OCP
 - 클래스가 확장에는 열려있고 수정에는 닫혀있어야 한다
 - 새로운 기능을 추가하면서도 기존코드를 수정하지 않아야 한다
 - 재사용성을 추구

 리스코프 교체의 원칙 - LSP
 - 프로그램에 존재하는 부모유형(T)의 객체를 자식유형(S) 의 객체로 교체할 수있어야 함
  T 와 S 간 상속관계가 적절해야 한다는 의미
  LSP 가 만족되면 새로운 자식클래스를 추가할 때 기존코드의 수정이 필요없음
  자식 클래스에서 부모클래스의 메소드를 재정의하지 않으면 LSP문제 없음
  자식 클래스에서 부모 클래스의 메소드를 재정의 하는 경우?

 인터페이스 분리의 원칙 - ISP
 - 하나의 규모가 큰 범용 인터페이스 사용 X, 작고 특화된 여러 인터페이스로 나누어 설계할 것
 - ISP를 만족하지 못하면 사용하지 않는 인터페이스가 바뀔 때에도 클라이언트에게 소프트웨어를 재배포 해야함
 - ex) 복합기 인터페이스 대신 프린팅, 복사, 스캔 인터페이스로 나눌 것

 의존 관계 역전의 원칙 - DIP
 - 구체적 저수준 사물(구체 클래스)이 아닌 추상적 고수준 개념(인터페이스)에 의존해야 함
 - 실제 작업을 수행하는 저수준 구체 클래스는 변경되기 쉬움